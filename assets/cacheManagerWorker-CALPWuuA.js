(function(){"use strict";const L=r=>r!==null&&typeof r=="object"&&"hash"in r&&typeof r.hash=="string"&&"size"in r&&typeof r.size=="number",j=(r,n,m)=>`corpus/${r}/${n}_${m}.txt.gz`;function k(r){const n=r.corpus,m=Object.keys(n.collections),u=Object.entries(n.collections);return{_corpus:n,collections:m,languages:n.languages,entries:u,metadata:r.metadata,getCollection:l=>n.collections[l],isCollectionKey:l=>m.some(d=>l===d),isLanguageKey:l=>n.languages.some(d=>l===d)}}const q="corpus",M=r=>"/poke-corpus/"+r,v=r=>{const n=e=>b(e).size,m=async(e,t)=>{const[a,o]=await h(e,t);return o?.hash===a.hash?0:a.size},u=async(e=r.collections)=>{try{const t=await w(),a=(await Promise.all(e.flatMap(o=>r.getCollection(o).languages.flatMap(s=>r.getCollection(o).files.map(c=>m(t,j(o,s,c))))))).reduce((o,s)=>o+s,0);return t.close(),a}catch{return e.flatMap(t=>r.getCollection(t).languages.flatMap(a=>r.getCollection(t).files.map(o=>n(j(t,a,o))))).reduce((t,a)=>t+a,0)}},l=async(e,t,a)=>{const o=M(a),[s,c]=await h(t,a);if(c?.hash===s.hash||!navigator.onLine&&c?.hash!==void 0){const p=await F(e,o);if(p!==void 0)return p}const f=await fetch(o);return f.ok?(await x(e,o,f).then(async p=>{p&&await C(t,a)}),f):await F(e,o)??null},d=async(e,t,a)=>{const o=M(a),[s,c]=await h(t,a);return c!==void 0?[await F(e,o),c.hash===s.hash]:[void 0,!1]},B=async e=>{const t=M(e),a=await fetch(t);return a.ok?a:null},y="corpus",i="files",w=()=>{const e=indexedDB.open(y);return new Promise((t,a)=>{e.onupgradeneeded=()=>{e.result.createObjectStore(i),e.transaction!==null&&(e.transaction.oncomplete=()=>{console.log("Created object store")})},e.onsuccess=()=>{t(e.result)},e.onerror=()=>{a(e.error)}})},b=e=>r.metadata[e],S=(e,t)=>{const s=e.transaction([i],"readonly").objectStore(i).get(t);return new Promise((c,f)=>{s.onsuccess=()=>{c(L(s.result)?s.result:void 0)},s.onerror=()=>{f(s.error)}})},C=(e,t)=>{const s=e.transaction([i],"readwrite").objectStore(i).put(b(t),t);return new Promise((c,f)=>{s.onsuccess=()=>{c(s.result===t)},s.onerror=()=>{f(s.error)}})},g=(e,t)=>{const s=e.transaction([i],"readwrite").objectStore(i).delete(t);return new Promise((c,f)=>{s.onsuccess=()=>{c(!0)},s.onerror=()=>{f(s.error)}})},h=async(e,t)=>[b(t),await S(e,t)],P=()=>w().then(e=>{const o=e.transaction(["files"],"readwrite").objectStore("files").clear();return e.close(),new Promise((s,c)=>{o.onsuccess=()=>{s(!0)},o.onerror=()=>{c(o.error)}})}),z=()=>w().then(e=>{const o=e.transaction([i],"readonly").objectStore(i).getAllKeys();return e.close(),new Promise((s,c)=>{o.onsuccess=()=>{s(o.result.filter(f=>typeof f=="string"))},o.onerror=()=>{c(o.error)}})}),O=async()=>await caches.open(q),F=async(e,t)=>{try{return await e.match(t)}catch(a){console.error(a);return}},x=async(e,t,a)=>{try{return await e.put(t,a.clone()),!0}catch(o){return console.error(o),!1}};return{corpus:r,getFilePath:j,getFileSize:n,getDownloadSizeTotal:u,getFile:l,getFileCacheOnly:d,getFileRemote:B,getIndexedDB:w,deleteLocalMetadata:g,clearLocalMetadata:P,getAllLocalFilePaths:z,getCache:O}};function D(r){return v(r)}self.onmessage=async r=>{const n=l=>{postMessage(l)},{serializedCorpus:m,requestedCollection:u}=r.data;try{const l=k(m),d=D(l),y=(u==="cacheAll"||u==="background"?l.entries:l.entries.filter(([g])=>g===u)).flatMap(([g,h])=>h.files.flatMap(P=>h.languages.map(z=>d.getFilePath(g,z,P))));let i=0;const w=y.reduce((g,h)=>g+d.getFileSize(h),0);n({status:"loading",loadedBytes:i,totalBytes:w,requestedCollection:u});const[b,S]=await Promise.all([d.getCache(),d.getIndexedDB()]),C=await Promise.all(y.map(g=>d.getFile(b,S,g).then(h=>h===null?!1:(i+=d.getFileSize(g),n({status:"loading",loadedBytes:i,totalBytes:w,requestedCollection:u}),!0))));S.close(),C.some(g=>!g)?(n({status:"error",loadedBytes:0,totalBytes:0,requestedCollection:u}),console.debug("Caching worker error")):(n({status:"done",loadedBytes:i,totalBytes:w,requestedCollection:u}),console.debug("Caching worker complete"))}catch(l){console.error(l),n({status:"error",loadedBytes:0,totalBytes:0,requestedCollection:u}),console.debug("Caching worker error")}}})();
