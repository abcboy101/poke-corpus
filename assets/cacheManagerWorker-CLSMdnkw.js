(function(){"use strict";const L=r=>r!==null&&typeof r=="object"&&"hash"in r&&typeof r.hash=="string"&&"size"in r&&typeof r.size=="number",p=(r,c,y)=>`corpus/${r}/${c}_${y}.txt.gz`;function k(r){const c=r.corpus,y=Object.keys(c.collections),d=Object.entries(c.collections);return{_corpus:c,collections:y,languages:c.languages,entries:d,metadata:r.metadata,getCollection:l=>c.collections[l],isCollectionKey:l=>y.some(g=>l===g),isLanguageKey:l=>c.languages.some(g=>l===g)}}const q="corpus",M=r=>"/poke-corpus/"+r,v=r=>{const c=e=>w(e).size,y=async(e,a)=>{const[t,o]=await h(e,a);return o?.hash===t.hash?0:t.size},d=async(e=r.collections,a=r.languages)=>{try{const t=await m(),o=(await Promise.all(e.flatMap(s=>r.getCollection(s).languages.filter(n=>a.includes(n)).flatMap(n=>r.getCollection(s).files.map(u=>y(t,p(s,n,u))))))).reduce((s,n)=>s+n,0);return t.close(),o}catch{return e.flatMap(t=>r.getCollection(t).languages.filter(o=>a.includes(o)).flatMap(o=>r.getCollection(t).files.map(s=>c(p(t,o,s))))).reduce((t,o)=>t+o,0)}},l=async(e,a,t)=>{const o=M(t),[s,n]=await h(a,t);if(n?.hash===s.hash||!navigator.onLine&&n?.hash!==void 0){const j=await F(e,o);if(j!==void 0)return j}const u=await fetch(o);return u.ok?(await x(e,o,u).then(async j=>{j&&await C(a,t)}),u):await F(e,o)??null},g=async(e,a,t)=>{const o=M(t),[s,n]=await h(a,t);return n!==void 0?[await F(e,o),n.hash===s.hash]:[void 0,!1]},B=async e=>{const a=M(e),t=await fetch(a);return t.ok?t:null},b="corpus",i="files",m=async()=>{const e=indexedDB.open(b);return new Promise((a,t)=>{e.onupgradeneeded=()=>{e.result.createObjectStore(i),e.transaction!==null&&(e.transaction.oncomplete=()=>{console.log("Created object store")})},e.onsuccess=()=>{a(e.result)},e.onerror=()=>{t(e.error)}})},w=e=>r.metadata[e],S=async(e,a)=>{const s=e.transaction([i],"readonly").objectStore(i).get(a);return new Promise((n,u)=>{s.onsuccess=()=>{n(L(s.result)?s.result:void 0)},s.onerror=()=>{u(s.error)}})},C=async(e,a)=>{const s=e.transaction([i],"readwrite").objectStore(i).put(w(a),a);return new Promise((n,u)=>{s.onsuccess=()=>{n(s.result===a)},s.onerror=()=>{u(s.error)}})},f=async(e,a)=>{const s=e.transaction([i],"readwrite").objectStore(i).delete(a);return new Promise((n,u)=>{s.onsuccess=()=>{n(!0)},s.onerror=()=>{u(s.error)}})},h=async(e,a)=>[w(a),await S(e,a)],P=async e=>{const o=e.transaction(["files"],"readwrite").objectStore("files").clear();return e.close(),new Promise((s,n)=>{o.onsuccess=()=>{s(!0)},o.onerror=()=>{n(o.error)}})},z=async e=>{const o=e.transaction([i],"readonly").objectStore(i).getAllKeys();return new Promise((s,n)=>{o.onsuccess=()=>{s(o.result.filter(u=>typeof u=="string"))},o.onerror=()=>{n(o.error)}})},O=async()=>await caches.open(q),F=async(e,a)=>{try{return await e.match(a)}catch(t){console.error(t);return}},x=async(e,a,t)=>{try{return await e.put(a,t.clone()),!0}catch(o){return console.error(o),!1}};return{corpus:r,getFilePath:p,getFileSize:c,getDownloadSizeTotal:d,getFile:l,getFileCacheOnly:g,getFileRemote:B,getIndexedDB:m,deleteLocalMetadata:f,clearLocalMetadata:P,getAllLocalFilePaths:z,getCache:O}};function D(r){return v(r)}self.onmessage=async r=>{const c=l=>{postMessage(l)},{serializedCorpus:y,requestedCollection:d}=r.data;try{const l=k(y),g=D(l),b=(d==="cacheAll"||d==="background"?l.entries:l.entries.filter(([f])=>f===d)).flatMap(([f,h])=>h.files.flatMap(P=>h.languages.map(z=>g.getFilePath(f,z,P))));let i=0;const m=b.reduce((f,h)=>f+g.getFileSize(h),0);c({status:"loading",loadedBytes:i,totalBytes:m,requestedCollection:d});const[w,S]=await Promise.all([g.getCache(),g.getIndexedDB()]),C=await Promise.all(b.map(f=>g.getFile(w,S,f).then(h=>h===null?!1:(i+=g.getFileSize(f),c({status:"loading",loadedBytes:i,totalBytes:m,requestedCollection:d}),!0))));S.close(),C.some(f=>!f)?(c({status:"error",loadedBytes:0,totalBytes:0,requestedCollection:d}),console.debug("Caching worker error")):(c({status:"done",loadedBytes:i,totalBytes:m,requestedCollection:d}),console.debug("Caching worker complete"))}catch(l){console.error(l),c({status:"error",loadedBytes:0,totalBytes:0,requestedCollection:d}),console.debug("Caching worker error")}}})();
