(function(){"use strict";const B=r=>r!==null&&typeof r=="object"&&"hash"in r&&typeof r.hash=="string"&&"size"in r&&typeof r.size=="number",M=(r,n,h)=>`corpus/${r}/${n}_${h}.txt.gz`,L="corpus";function k(r){const n=r.corpus,h=Object.keys(n.collections),u=Object.entries(n.collections);return{_corpus:n,collections:h,languages:n.languages,entries:u,metadata:r.metadata,getCollection:c=>n.collections[c],isCollectionKey:c=>h.some(d=>c===d),isLanguageKey:c=>n.languages.some(d=>c===d)}}const q=r=>{const n=e=>y(e).size,h=async(e,t)=>{const[a,o]=await S(e,t);return o?.hash===a.hash?0:a.size},u=async(e=r.collections)=>{try{const t=await b(),a=(await Promise.all(e.flatMap(o=>r.getCollection(o).languages.flatMap(s=>r.getCollection(o).files.map(l=>h(t,M(o,s,l))))))).reduce((o,s)=>o+s,0);return t.close(),a}catch{return e.flatMap(t=>r.getCollection(t).languages.flatMap(a=>r.getCollection(t).files.map(o=>n(M(t,a,o))))).reduce((t,a)=>t+a,0)}},c=e=>"/poke-corpus/"+e,d=async(e,t,a)=>{const o=c(a),[s,l]=await S(t,a);if(l?.hash===s.hash||!navigator.onLine&&l?.hash!==void 0){const j=await z(e,o);if(j!==void 0)return j}const f=await fetch(o);return f.ok?(await x(e,o,f).then(async j=>{j&&await g(t,a)}),f):await z(e,o)??null},F=async(e,t,a)=>{const o=c(a),[s,l]=await S(t,a);return l!==void 0?[await z(e,o),l.hash===s.hash]:[void 0,!1]},p=async e=>{const t=c(e),a=await fetch(t);return a.ok?a:null},w="corpus",i="files",b=()=>{const e=indexedDB.open(w);return new Promise((t,a)=>{e.onupgradeneeded=()=>{e.result.createObjectStore(i),e.transaction!==null&&(e.transaction.oncomplete=()=>{console.log("Created object store")})},e.onsuccess=()=>{t(e.result)},e.onerror=()=>{a(e.error)}})},y=e=>r.metadata[e],C=(e,t)=>{const s=e.transaction([i],"readonly").objectStore(i).get(t);return new Promise((l,f)=>{s.onsuccess=()=>{l(B(s.result)?s.result:void 0)},s.onerror=()=>{f(s.error)}})},g=(e,t)=>{const s=e.transaction([i],"readwrite").objectStore(i).put(y(t),t);return new Promise((l,f)=>{s.onsuccess=()=>{l(s.result===t)},s.onerror=()=>{f(s.error)}})},m=(e,t)=>{const s=e.transaction([i],"readwrite").objectStore(i).delete(t);return new Promise((l,f)=>{s.onsuccess=()=>{l(!0)},s.onerror=()=>{f(s.error)}})},S=async(e,t)=>[y(t),await C(e,t)],P=()=>b().then(e=>{const o=e.transaction(["files"],"readwrite").objectStore("files").clear();return e.close(),new Promise((s,l)=>{o.onsuccess=()=>{s(!0)},o.onerror=()=>{l(o.error)}})}),D=()=>b().then(e=>{const o=e.transaction([i],"readonly").objectStore(i).getAllKeys();return e.close(),new Promise((s,l)=>{o.onsuccess=()=>{s(o.result.filter(f=>typeof f=="string"))},o.onerror=()=>{l(o.error)}})}),O=async()=>await caches.open(L),z=async(e,t)=>{try{return await e.match(t)}catch(a){console.error(a);return}},x=async(e,t,a)=>{try{return await e.put(t,a.clone()),!0}catch(o){return console.error(o),!1}};return{corpus:r,getFilePath:M,getFileSize:n,getDownloadSizeTotal:u,getFile:d,getFileCacheOnly:F,getFileRemote:p,getIndexedDB:b,deleteLocalMetadata:m,clearLocalMetadata:P,getAllLocalFilePaths:D,getCache:O}};function v(r){return q(r)}self.onmessage=async r=>{const n=c=>{postMessage(c)},{serializedCorpus:h,requestedCollection:u}=r.data;try{const c=k(h),d=v(c),p=(u==="cacheAll"||u==="background"?c.entries:c.entries.filter(([g])=>g===u)).flatMap(([g,m])=>m.files.flatMap(S=>m.languages.map(P=>d.getFilePath(g,P,S))));let w=0;const i=p.reduce((g,m)=>g+d.getFileSize(m),0);n({status:"loading",loadedBytes:w,totalBytes:i,requestedCollection:u});const[b,y]=await Promise.all([d.getCache(),d.getIndexedDB()]),C=await Promise.all(p.map(g=>d.getFile(b,y,g).then(m=>m===null?!1:(w+=d.getFileSize(g),n({status:"loading",loadedBytes:w,totalBytes:i,requestedCollection:u}),!0))));y.close(),C.some(g=>!g)?(n({status:"error",loadedBytes:0,totalBytes:0,requestedCollection:u}),console.debug("Caching worker error")):(n({status:"done",loadedBytes:w,totalBytes:i,requestedCollection:u}),console.debug("Caching worker complete"))}catch(c){console.error(c),n({status:"error",loadedBytes:0,totalBytes:0,requestedCollection:u}),console.debug("Caching worker error")}}})();
