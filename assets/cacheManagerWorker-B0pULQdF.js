(function(){"use strict";const F=r=>r!==null&&typeof r=="object"&&"hash"in r&&typeof r.hash=="string"&&"size"in r&&typeof r.size=="number",M=(r,l,h)=>`corpus/${r}/${l}_${h}.txt.gz`;function L(r){const l=r.corpus,h=Object.keys(l.collections),d=Object.entries(l.collections);return{_corpus:l,collections:h,languages:l.languages,entries:d,metadata:r.metadata,getCollection:n=>l.collections[n],isCollectionKey:n=>h.some(u=>n===u),isLanguageKey:n=>l.languages.some(u=>n===u)}}const q=r=>{const l=e=>b(e).size,h=async(e,t)=>{const[a,o]=await S(e,t);return o?.hash===a.hash?0:a.size},d=async(e=r.collections)=>{try{const t=await w(),a=(await Promise.all(e.flatMap(o=>r.getCollection(o).languages.flatMap(s=>r.getCollection(o).files.map(c=>h(t,M(o,s,c))))))).reduce((o,s)=>o+s,0);return t.close(),a}catch{return e.flatMap(t=>r.getCollection(t).languages.flatMap(a=>r.getCollection(t).files.map(o=>l(M(t,a,o))))).reduce((t,a)=>t+a,0)}},n=e=>"/poke-corpus/"+e,u=async(e,t,a)=>{const o=n(a),[s,c]=await S(t,a);if(c?.hash===s.hash||!navigator.onLine&&c?.hash!==void 0){const j=await z(e,o);if(j!==void 0)return j}const f=await fetch(o);return await x(e,o,f).then(async j=>{j&&await y(t,a)}),f},P=async(e,t,a)=>{const o=n(a),[s,c]=await S(t,a);return c!==void 0?[await z(e,o),c.hash===s.hash]:[void 0,!1]},p=e=>{const t=n(e);return fetch(t)},m="corpus",i="files",w=()=>{const e=indexedDB.open(m);return new Promise((t,a)=>{e.onupgradeneeded=()=>{e.result.createObjectStore(i),e.transaction!==null&&(e.transaction.oncomplete=()=>{console.log("Created object store")})},e.onsuccess=()=>{t(e.result)},e.onerror=()=>{a(e.error)}})},b=e=>r.metadata[e],g=(e,t)=>{const s=e.transaction([i],"readonly").objectStore(i).get(t);return new Promise((c,f)=>{s.onsuccess=()=>{c(F(s.result)?s.result:void 0)},s.onerror=()=>{f(s.error)}})},y=(e,t)=>{const s=e.transaction([i],"readwrite").objectStore(i).put(b(t),t);return new Promise((c,f)=>{s.onsuccess=()=>{c(s.result===t)},s.onerror=()=>{f(s.error)}})},C=(e,t)=>{const s=e.transaction([i],"readwrite").objectStore(i).delete(t);return new Promise((c,f)=>{s.onsuccess=()=>{c(!0)},s.onerror=()=>{f(s.error)}})},S=async(e,t)=>[b(t),await g(e,t)],B=()=>w().then(e=>{const o=e.transaction(["files"],"readwrite").objectStore("files").clear();return e.close(),new Promise((s,c)=>{o.onsuccess=()=>{s(!0)},o.onerror=()=>{c(o.error)}})}),k=()=>w().then(e=>{const o=e.transaction([i],"readonly").objectStore(i).getAllKeys();return e.close(),new Promise((s,c)=>{o.onsuccess=()=>{s(o.result.filter(f=>typeof f=="string"))},o.onerror=()=>{c(o.error)}})}),D="corpus",O=async()=>await caches.open(D),z=async(e,t)=>{try{return await e.match(t)}catch(a){console.error(a);return}},x=async(e,t,a)=>{try{return await e.put(t,a.clone()),!0}catch(o){return console.error(o),!1}};return{corpus:r,getFilePath:M,getFileSize:l,getDownloadSizeTotal:d,getFile:u,getFileCacheOnly:P,getFileRemote:p,getIndexedDB:w,deleteLocalMetadata:C,clearLocalMetadata:B,getAllLocalFilePaths:k,getCache:O}};function v(r){return q(r)}self.onmessage=async r=>{const l=n=>{postMessage(n)},{serializedCorpus:h,requestedCollection:d}=r.data;try{const n=L(h),u=v(n),p=(d==="cacheAll"||d==="background"?n.entries:n.entries.filter(([g])=>g===d)).flatMap(([g,y])=>y.files.flatMap(C=>y.languages.map(S=>u.getFilePath(g,S,C))));let m=0;const i=p.reduce((g,y)=>g+u.getFileSize(y),0);l({status:"loading",loadedBytes:m,totalBytes:i,requestedCollection:d});const[w,b]=await Promise.all([u.getCache(),u.getIndexedDB()]);await Promise.all(p.map(g=>u.getFile(w,b,g).then(()=>{m+=u.getFileSize(g),l({status:"loading",loadedBytes:m,totalBytes:i,requestedCollection:d})}))),b.close(),l({status:"done",loadedBytes:m,totalBytes:i,requestedCollection:d}),console.debug("Caching worker complete")}catch(n){console.error(n),l({status:"error",loadedBytes:0,totalBytes:0,requestedCollection:d}),console.debug("Caching worker error")}}})();
